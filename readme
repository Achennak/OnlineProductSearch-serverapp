### ASSIGNMENT 6
### <ins> Design considerations and explanations :
### Interface segregation on flexible and inflexible portfolio

<ins>_**WHY:**_</ins> 

Previously, flexible and inflexible portfolios shared comparable duties, and it was assumed that a flexible portfolio "is-a" inflexible portfolio with certain additional powers. However, as the program grows in size without interface segregation, some functions will be left unused in some implementations. Thus, in order to provide a more extensible architecture to the code, we opted to implement the portfolios from different interfaces while still extending a common interface that contains implementations that are common to both portfolios.

 <ins>_**HOW IS THIS EXTENSIBLE? :**_</ins>  

In the future, new operations on flexible portfolios can be implemented without affecting the inflexible portfolio, and vice versa. The common functions can be added to the common interface and implemented by the abstract class, making them flexible and expandable to a significant extent.

### GUI View and Text view in implemented in Interface segregation

_Explanation_ : 

Although both implementations perform similar functions, there is a good likelihood that in the future, there will be more separate requirements for both of them, requiring them to act in different ways. Keeping this in mind, we implemented interface isolation to the GUI and Text views, with shared functionality under a Common Interface (CommonStockView).

### Strategy

We introduced a new class called Strategy in this assignment, which may be used to a "Flexible" portfolio. It is designed with the idea that "a flexible portfolio can have various strategies."

For the time being, we have Dollar cost averaging in place while creating a Strategy interface. So, if any more such strategies emerge in the future, they would implement Strategy interface while maintaining the same interface design.

### Graph

We used jFree chart jars to implement performance over time as a line chart in the GUI. Because there was no specific mention of graph scaling this time in charts, the graph is auto scaled and will not range from 0 to 50 but rather appear with absolute values.

### GUI view and controller features

We implemented a new controller for GUI view which provides action listeners for GUI views as features. The features are knows to view as they are passed by the controller and hence when any activity happens in view the feature function in the controller will be invoked to action.

### Singleton Design Pattern on panels

The singleton design pattern is used to create all of the screen panels. As a result, regardless of how many times a panel loads (i.e., the user can navigate between displays), the class instance is only created once. This will also ensure that each panel has only one instance in memory at a time, making referring them much easier.

### Segregation of UI panels

Because the program has numerous screens, each screen is divided into panels, and each implementation is put into a different package and implemented in a distinct class so that they are scalable and easy to maintain.

## File changes

A variety of strategies are now available in the flexible portfolio. When a portfolio is loaded, the strategies are examined, and if today's date falls between the start and finish dates, the strategy is loaded, and stocks are "purchased" and saved. The start date is updated to the start date of the next cycle until it reaches the end date.

Users are provided with 2 options for Dollar cost averaging investment :

1. Create a flexible portfolio with a strategy 

2. Implement strategy to existing portfolio  

The portfolio with a strategies look something like this.

Users can also _load_ a portfolio with strategy "**as long as they adhere to the same schema**."

If the strategy is terminated (i.e., the strategy's end date is before today), the dates are changed to infinity after loading the strategy (purchasing stocks), and they will never be loaded back.

